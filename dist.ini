name			= Pod-Spell-CommonMistakes
author			= Apocalypse <APOCAL@cpan.org>
license			= Perl_5
copyright_holder	= Apocalypse

; -- start off by bumping the version
[BumpVersionFromGit]		; find the last tag, and bump to next version via Version::Next
version_regexp = ^release-(.+)$

; -- start the basic dist skeleton
[AllFiles]			; we start with everything in the dist dir
[PruneCruft]			; automatically prune cruft defined by RJBS :)
[AutoPrereq]			; automatically find our prereqs
[GenerateFile / MANIFEST.SKIP]	; make our MANIFEST.SKIP
filename = MANIFEST.SKIP
content = # List generated by looking at ExtUtils::Manifest and Module::Build's code :)
content =
content = # skip Eclipse IDE stuff
content = \.includepath$
content = \.project$
content = \.settings/
content =
content = # Avoid version control files.
content = \bRCS\b
content = \bCVS\b
content = ,v$
content = \B\.svn\b
content = \B\.git\b
content = ^\.gitignore$
content =
content = # Avoid configuration metadata file
content = ^MYMETA\.
content =
content = # Avoid Makemaker generated and utility files.
content = ^Makefile$
content = ^blib/
content = ^MakeMaker-\d
content = \bpm_to_blib$
content =
content = # Avoid Module::Build generated and utility files.
content = \bBuild$
content = \bBuild.bat$
content = \b_build
content = \bBuild.COM$
content = \bBUILD.COM$
content = \bbuild.com$
content =
content = # Avoid temp and backup files.
content = ~$
content = \.old$
content = \#$
content = ^\.#
content = \.bak$
content =
content = # our tarballs
content = \.tar\.gz$
content = ^releases/
[ManifestSkip]			; skip files that matches MANIFEST.SKIP
skipfile = MANIFEST.SKIP

; -- Generate our tests
[CompileTests]			; Create a t/00-compile.t file that auto-compiles every module in the dist
[ApocalypseTests]		; Create a t/apocalypse.t file that runs Test::Apocalypse

; -- munge files
[Prepender]			; automatically add lines following the shebang in modules
copyright = 1
line = use strict; use warnings;
[PkgVersion]			; put the "our $VERSION = ...;" line in modules
[PodWeaver]			; weave our POD and add useful boilerplate
;config_plugin = @APOCAL # TODO use my PodWeaver bundle

; -- update the Changelog
[NextRelease] ; the time_zone param requires unreleased dzil, gotta wait for rjbs to release it :)
time_zone = UTC
filename = Changes
format = * %v%n%tReleased: %{yyyy-MM-dd HH:mm:ss VVVV}d
[ChangelogFromGit]		; generate CommitLog from git history
tag_regexp = ^release-(.+)$
file_name = CommitLog

; -- generate/process meta-information
[ExecDir]			; automatically install files from bin/ directory as executables # TODO enable only if bin exists
dir = bin
[ShareDir]			; automatically install File::ShareDir files from share/ # TODO enable only if share exists
dir = share
[MetaProvides::Package]		; get provides from package definitions in files
[Bugtracker]			; set bugtracker to http://rt.cpan.org/Public/Dist/Display.html?Name=$dist
[Repository]			; set git repository path by looking at git configs
git_remote = origin
[Homepage]			; set homepage to http://search.cpan.org/dist/$dist/
[MetaResources]			; add arbitrary resources to metadata # TODO add the usual list of stuff found in my POD?
license = http://dev.perl.org/licenses/
[MetaConfig]			; dump dzil config into metadata

; -- generate meta files
[MetaNoIndex]			; tell PAUSE to not index those stuff # TODO add only if they exist! ( look at DZP::Bundle::AVAR )
directory = inc
directory = t
directory = xt
directory = examples
directory = share
[License]			; create LICENSE file
[MakeMaker]			; create Makefile.PL file
[ModuleBuild]			; create Build.PL file
[DualBuilders]			; have M::B and EU::MM but select only M::B as prereq
prefer = build
[MetaYAML]			; create META.yml file
[MetaJSON]			; create META.json file
[ReadmeFromPod]			; create README file
[InstallGuide]			; create INSTALL file
;[Signature]			; create SIGNATURE file when we are building a release ( TODO setup Module::Signature )
;sign = archive
[Manifest]			; finally, create the MANIFEST file ( must be the last thing we do )

; -- pre-release
[Git::Check]			; check working path for any uncommitted stuff ( exempt Changes because it will be committed after release )
changelog = Changes
[ConfirmRelease]		; double-check that we ACTUALLY want a release, ha!

; -- release
;[UploadToCPAN]	TODO not yet... I don't want to accidentally upload stuff!

; -- post-release
[ArchiveRelease]		; archive our tarballs under releases/
directory = releases
[Git::Commit]			; commit the dzil-generated stuff
changelog = Changes
commit_msg = New release of %N - v%v
[Git::Tag]			; tag our new release
tag_format = release-%v
tag_message = release-%v
[Git::Push]			; automatically push to the "origin" defined in .git/config # TODO rename to "github" so we can add "gitorious" heh
push_to = origin
